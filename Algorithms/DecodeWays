// reference: http://blog.csdn.net/linhuanmars/article/details/24570759
//算法的时间复杂度是O(n)。空间上可以看出我们每次只需要前两位的历史信息，所以只需要维护三个变量然后迭代赋值就可以了，所以空间复杂度是O(1)。代
public class Solution {
    public int numDecodings(String s) {
        if(s == null || s.length() == 0 || s.charAt(0) == '0') return 0; 
        
        int old = 1;
        int pre = 1;
        int cur = 1;
        
        for(int i=1; i<s.length(); i++) {
            if(s.charAt(i)=='0') {
                if(s.charAt(i-1) == '1' || s.charAt(i-1) == '2') cur = old;
                else cur = 0;
            } else {
                if(s.charAt(i-1) == '1' || (s.charAt(i) >='1' && s.charAt(i) <='6' && s.charAt(i-1) == '2'))    cur = old+ pre;
                else cur = pre;
            }
            
            old = pre;
            pre = cur;
        }
        
        return cur;
    }
    

}

// my way, runtime O(n), space O(n)
public class Solution {
    public int numDecodings(String s) {
        if(s==null || s.length()==0) return 0;
        int[] res = new int[s.length()+1];
        res[0] = 1;
        res[1] = s.charAt(0) == '0' ? 0 : 1;
        for(int i = 1; i<s.length(); i++) {
            if(res[i-1]!=0 && s.charAt(i-1)!='0' && Integer.parseInt(s.substring(i-1,i+1))<=26) {
                res[i+1] += res[i-1];
            }
            if(res[i]!=0 && s.charAt(i)!='0') {
                res[i+1]+=res[i];
            }
        }
        return res[s.length()];
    }
}
